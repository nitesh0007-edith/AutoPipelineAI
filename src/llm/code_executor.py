"""
Safe Code Executor - Executes generated code in a controlled environment
"""
import pandas as pd
import re
from typing import Any, Dict, Optional, List
from loguru import logger
import ast


class SafeCodeExecutor:
    """Safely execute code generated by LLMs"""

    def __init__(self, allowed_modules: Optional[List[str]] = None):
        """
        Initialize executor with allowed modules

        Args:
            allowed_modules: List of allowed module names for import
        """
        self.allowed_modules = allowed_modules or [
            'pandas', 'numpy', 'plotly', 'matplotlib', 'seaborn',
            'datetime', 'json', 're', 'math', 'statistics'
        ]
        logger.info(f"Initialized SafeCodeExecutor with modules: {self.allowed_modules}")

    def extract_code_blocks(self, text: str, language: str = "python") -> List[str]:
        """
        Extract code blocks from markdown text

        Args:
            text: Text containing markdown code blocks
            language: Programming language (default: python)

        Returns:
            List of code block contents
        """
        pattern = rf"```{language}\s*(.*?)```"
        matches = re.findall(pattern, text, re.DOTALL)

        if matches:
            logger.info(f"Found {len(matches)} {language} code blocks")
            return [match.strip() for match in matches]

        # Try without language specifier
        pattern = r"```\s*(.*?)```"
        matches = re.findall(pattern, text, re.DOTALL)

        if matches:
            logger.info(f"Found {len(matches)} generic code blocks")
            return [match.strip() for match in matches]

        return []

    def check_code_safety(self, code: str) -> tuple[bool, Optional[str]]:
        """
        Check if code is safe to execute

        Args:
            code: Python code string

        Returns:
            Tuple of (is_safe, error_message)
        """
        dangerous_patterns = [
            (r'\bos\.system\b', "os.system() calls are not allowed"),
            (r'\beval\b', "eval() is not allowed"),
            (r'\bexec\b', "exec() is not allowed (use SafeCodeExecutor)"),
            (r'\b__import__\b', "__import__() is not allowed"),
            (r'\bopen\([^)]*[\'"]w', "Writing files is restricted"),
            (r'\bsubprocess\b', "subprocess module is not allowed"),
            (r'\bshutil\.rmtree\b', "Deleting directories is not allowed"),
            (r'\bos\.remove\b', "Deleting files is not allowed"),
        ]

        for pattern, error_msg in dangerous_patterns:
            if re.search(pattern, code):
                logger.warning(f"Unsafe code detected: {error_msg}")
                return False, error_msg

        # Check imports
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if alias.name.split('.')[0] not in self.allowed_modules:
                            return False, f"Import of '{alias.name}' is not allowed"
                elif isinstance(node, ast.ImportFrom):
                    if node.module and node.module.split('.')[0] not in self.allowed_modules:
                        return False, f"Import from '{node.module}' is not allowed"
        except SyntaxError as e:
            return False, f"Syntax error in code: {e}"

        return True, None

    def execute_code(
        self,
        code: str,
        context: Optional[Dict[str, Any]] = None,
        capture_output: bool = True
    ) -> Dict[str, Any]:
        """
        Execute Python code safely

        Args:
            code: Python code to execute
            context: Dictionary of variables to make available (e.g., {'df': dataframe})
            capture_output: Whether to capture print statements

        Returns:
            Dictionary with keys: success, result, output, error
        """
        # Check safety
        is_safe, error_msg = self.check_code_safety(code)
        if not is_safe:
            return {
                "success": False,
                "result": None,
                "output": "",
                "error": f"Safety check failed: {error_msg}"
            }

        # Prepare execution context
        exec_globals = context.copy() if context else {}
        exec_locals = {}

        # Add safe builtins
        exec_globals.update({
            'pd': pd,
            '__builtins__': __builtins__,
        })

        try:
            # Capture stdout if requested
            if capture_output:
                import io
                import sys
                old_stdout = sys.stdout
                sys.stdout = captured_output = io.StringIO()

            # Execute code
            exec(code, exec_globals, exec_locals)

            # Restore stdout
            if capture_output:
                sys.stdout = old_stdout
                output = captured_output.getvalue()
            else:
                output = ""

            # Get result if it exists
            result = exec_locals.get('result', None)

            logger.success("Code executed successfully")
            return {
                "success": True,
                "result": result,
                "output": output,
                "error": None
            }

        except Exception as e:
            if capture_output:
                sys.stdout = old_stdout

            logger.error(f"Error executing code: {e}")
            return {
                "success": False,
                "result": None,
                "output": "",
                "error": str(e)
            }

    def execute_from_llm_response(
        self,
        llm_response: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Extract and execute code from LLM response

        Args:
            llm_response: Full response from LLM
            context: Execution context variables

        Returns:
            Execution result dictionary
        """
        code_blocks = self.extract_code_blocks(llm_response)

        if not code_blocks:
            logger.warning("No code blocks found in LLM response")
            return {
                "success": False,
                "result": None,
                "output": "",
                "error": "No code blocks found in response"
            }

        # Execute the first (or combined) code block
        code = "\n\n".join(code_blocks)
        return self.execute_code(code, context)
